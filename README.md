## 과제 체크포인트

### 배포 링크

https://hanbeulyou.github.io/front_5th_chapter1-2/

### 기본과제

#### 가상돔을 기반으로 렌더링하기

- [x] createVNode 함수를 이용하여 vNode를 만든다.
- [x] normalizeVNode 함수를 이용하여 vNode를 정규화한다.
- [x] createElement 함수를 이용하여 vNode를 실제 DOM으로 만든다.
- [x] 결과적으로, JSX를 실제 DOM으로 변환할 수 있도록 만들었다.

#### 이벤트 위임

- [x] 노드를 생성할 때 이벤트를 직접 등록하는게 아니라 이벤트 위임 방식으로 등록해야 한다
- [x] 동적으로 추가된 요소에도 이벤트가 정상적으로 작동해야 한다
- [x] 이벤트 핸들러가 제거되면 더 이상 호출되지 않아야 한다

### 심화 과제

#### 1) Diff 알고리즘 구현

- [x] 초기 렌더링이 올바르게 수행되어야 한다
- [x] diff 알고리즘을 통해 변경된 부분만 업데이트해야 한다
- [x] 새로운 요소를 추가하고 불필요한 요소를 제거해야 한다
- [x] 요소의 속성만 변경되었을 때 요소를 재사용해야 한다
- [x] 요소의 타입이 변경되었을 때 새로운 요소를 생성해야 한다

#### 2) 포스트 추가/좋아요 기능 구현

- [x] 비사용자는 포스트 작성 폼이 보이지 않는다
- [x] 비사용자는 포스트에 좋아요를 클릭할 경우, 경고 메세지가 발생한다.
- [x] 사용자는 포스트 작성 폼이 보인다.
- [x] 사용자는 포스트를 추가할 수 있다.
- [x] 사용자는 포스트에 좋아요를 클릭할 경우, 좋아요가 토글된다.

## 과제 셀프회고

처음 virtual DOM을 구현한다고 했을 때, 막연함부터 들었다. JSX는 쓰는 데 익숙했지만 그것이 실제로 어떤 구조의 데이터로 바뀌는지, DOM과 어떻게 연결되는지 제대로 생각해본 적은 없었다. 그저 “컴포넌트가 함수처럼 작동하고 React가 알아서 처리해준다”는 정도의 이해만 있었던 셈이다.

하지만 직접 virtual DOM을 만들기 시작하면서 단순히 객체 하나 만드는 것을 넘어서 복잡한 구조와 다양한 edge case를 고려해야 한다는 사실을 깨달았다. 이 과제는 단순한 학습을 넘어 리액트가 내부에서 어떻게 동작하는지를 몸으로 익히는 기회가 되었다.

### ⚙️ VNode 구조 설계와 JSX 처리

가장 먼저 구현하게 된 `createVNode` 함수는 그저 `{ type, props, children }` 객체를 반환하면 끝일 줄 알았다. 하지만 실제로 `JSX`를 사용할 때는 문자열, 숫자, 함수형 컴포넌트, `null`, `undefined`, `boolean`, 그리고 중첩된 배열 등 다양한 형태의 `children`이 들어온다. 이 구조는 생각보다 복잡했고, `JSX` 문법이 변환되는 구조를 이해하지 않으면 정상적으로 처리할 수 없다는 걸 깨달았다.

특히 `JSX`에서는 여러 계층의 `children`이 중첩 배열로 들어오기 때문에, 이를 평탄화하기 위한 `flattenChildren` 함수가 필요했다. 이 함수는 단순히 `children`을 1차원 배열로 만드는 것뿐 아니라, `null`, `undefined`, `boolean` 같은 렌더링할 수 없는 값도 걸러주는 역할을 한다. 처음에는 이런 전처리 없이 진행하다가 `children.map` 과정에서 오류가 발생하며, 이를 처리해야 한다는 걸 뒤늦게 알게 되었다.

또한 `normalizeVNode` 함수의 필요성도 시행착오를 겪으며 체감했다. `JSX`에서 컴포넌트가 함수 형태로 들어올 경우, 이를 실행해 실제 `VNode`로 변환해줘야 하는데, 이 정규화 단계를 거치지 않으면 정상적으로 렌더링되지 않는다. 처음에는 이 단계를 왜 거쳐야 하는지 몰랐지만, 결국 함수형 컴포넌트가 동작하지 않는 문제를 겪으며 그 필요성을 깨달았다. 정규화는 단순히 값들을 일관된 형태로 변환해주는 것이 아니라, `JSX`의 다양한 타입을 처리하고 재귀적으로 구조를 단순화하는 중요한 과정이었다.

### 🧩 Virtual DOM과 이벤트 위임

이벤트 위임 패턴은 지난 과제에서 먼저 구현해둔 상태였다. 하지만 이번 과제에서는 이를 `Virtual DOM` 시스템과 어떻게 연결할 것인지, 즉 `VNode` 단에서 정의된 이벤트 핸들러가 실제 `DOM`에 어떻게 반영되고, 이벤트 위임 시스템과 어떤 방식으로 연동되는지를 설계하는 것이 핵심이었다.

가장 먼저 고민한 부분은 이벤트 핸들러가 `props`를 통해 전달된다는 점이었다. `JSX`에서 `<div onClick={...}>`처럼 작성된 이벤트는 결국 `createVNode`를 거치며 `VNode` 객체의 `props`로 전달되며, 실제 `DOM` 요소로 변환되는 시점인 `createElement` 내부에서 처리해야 했다. 이때 "on"으로 시작하는 속성들을 감지해, 일반 속성이 아닌 이벤트로 분기하고, `addEvent()`를 호출해 이벤트를 위임 형태로 등록했다.

이 위임 구조는 `EventManager` 클래스 내부에서 구현되었고, 여기서 두 가지 주요 자료구조를 활용했다. 첫 번째는 `Map<HTMLElement, Function>` 형태의 맵으로, 어떤 타겟 요소가 어떤 이벤트 핸들러를 갖고 있는지를 저장하는 역할을 했다. 두 번째는 `WeakMap<HTMLElement, Set<string>>`으로, 루트 엘리먼트 단위로 이미 어떤 이벤트 타입이 등록되었는지를 기억하기 위한 용도로 사용했다. 이렇게 하면 동일한 루트에 동일한 이벤트가 중복 등록되는 걸 방지할 수 있고, 루트 DOM이 제거되면 자동으로 참조도 사라져 메모리 누수를 막을 수 있었다.

`VNode` → `createElement` → `EventManager(addEvent)`로 이어지는 이 흐름은 `Virtual DOM`에서 선언한 이벤트를 실제 `DOM`에 안전하고 일관되게 반영할 수 있도록 도와줬다. 단순히 `DOM`에 직접 `addEventListener`를 붙이는 방식이 아니라, 추상화된 이벤트 관리 시스템과 연계하는 구조를 만들어냄으로써, 이후 상태 변경이나 리렌더링 시에도 복잡도를 낮출 수 있었다.

### 🛠️ UpdateElement: Diff 알고리즘 구현

`Virtual DOM`의 핵심은 실제 `DOM`과 `VNode`의 차이를 최소한의 변경으로 동기화하는 것이다. 이 역할을 수행하는 중심 함수가 바로 `updateElement`였다. 이 함수는 이전에 렌더링된 `VNode`와 새롭게 렌더링될 `VNode`를 비교한 뒤, 바뀐 부분만 실제 `DOM`에 반영한다. 이 과정이 잘 작동해야 렌더링 최적화가 이루어지고, 불필요한 `DOM` 변경이나 이벤트 재등록 같은 부작용도 막을 수 있다.

처음에는 단순히 타입(`VNode.type`)만 비교해서 다르면 교체하고, 같으면 재귀적으로 자식까지 내려가면서 비교하는 구조로 설계했다. 그리고 `props`는 `updateAttributes`를 통해, `children`은 `updateElement`를 다시 재귀 호출하는 방식으로 처리했다. 기본적인 비교 알고리즘은 다음과 같은 단계로 나눴다:

- `null` 체크: `newNode`나 `oldNode`가 존재하지 않는 경우 노드를 추가하거나 제거
- 텍스트 노드 처리: `string`이나 `number`일 경우 `nodeValue`를 통해 값만 바꿈
- 타입 비교: 타입이 다르면 바로 교체
- 속성 비교: `updateAttributes`를 호출해서 변경된 `props`만 업데이트
- 자식 노드 재귀적 처리: 최대 자식 수만큼 반복하며 `updateElement` 재귀 호출

특별한 비교 함수(`shallowEqual` 같은)를 도입하지는 않았지만, 단순한 재귀 구조만으로도 의외로 많은 변경을 걸러낼 수 있었다. 전체 노드를 무작정 교체하기보단 필요한 부분만 업데이트하는 흐름을 직접 구현하면서, 자연스럽게 렌더링 최적화의 개념을 체감할 수 있었다.
다만 자식 노드의 순서 변경이나 중간 삽입 등 복잡한 구조에서는 한계가 명확히 드러났고, `key` 기반 `diffing`이나 상태 보존 같은 고급 전략이 왜 필요한지 분명히 느낄 수 있었다.
이전까지는 “렌더링이 된다 / 안 된다”의 결과만을 바라봤다면, 이번 경험을 통해 “렌더링이 어떻게 이루어지고, 어디서 낭비가 발생하는가”를 고민하는 시야를 갖게 되었다.

### 🌀 이벤트 핸들러 재등록 문제와 무한 렌더링 해결

이번 과제에서 가장 골치 아팠던 문제 중 하나는 무한 렌더링 현상이었다. 처음에는 `router.push()`가 계속 호출되면서 `updateElement()`가 끝없이 실행되는 것을 보며 원인을 추적했지만, 결론적으로 그 출발점은 이벤트 핸들러의 잘못된 재등록이었다.

초기에는 이벤트 핸들러가 바뀌었는지 여부를 단순히 `oldValue !== newValue`로 판단한 뒤, 매번 `removeEvent()` → `addEvent()` 순서로 이벤트를 덮어쓰는 방식으로 구현했었다. 이 방식은 핸들러 함수가 매 렌더링마다 새로 생성되는 경우(예: 화살표 함수 등)에는 동일한 동작임에도 불구하고 서로 다른 참조로 인식되기 때문에 항상 변경된 것으로 간주되었다. 그 결과, 이벤트를 계속 제거하고 다시 등록하는 불필요한 동작이 발생했고, 이 과정에서 상태 변경이 다시 발생하면서 무한 루프에 빠졌다.

```ts
if (originOldProps[key] !== value) {
  if (originOldProps[key]) {
    removeEvent(target, eventType, originOldProps[key]);
  }
  addEvent(target, eventType, value);
}
```

이 문제를 해결하기 위해 핸들러를 비교하는 로직을 변경했다. 핸들러가 변경된 경우라도 제거는 생략하고 등록만 시도하게 하고, 반대로 이벤트가 `props`에서 아예 사라졌을 때만 `removeEvent()`를 호출하는 구조로 바꿨다. 다음과 같은 흐름이다:

```ts
if (oldValue !== newValue) {
  addEvent(target, eventType, newValue);
}
```

```ts
if (!(originNewProps && key in originNewProps)) {
  removeEvent(target, eventType, oldValue);
}
```

기존에는 이벤트가 바뀌었을 때 항상 `remove` → `add`로 처리했지만, 이로 인해 참조가 달라졌다는 이유만으로 이벤트가 불필요하게 재등록되며 무한 렌더링이 발생했다. 이를 해결하기 위해 이벤트가 `props`에서 아예 사라졌을 때만 `removeEvent()`를 호출하고, 변경된 경우엔 등록만 수행하는 방식으로 로직을 분리했다. 이로써 불필요한 제거를 줄이고 렌더링 안정성을 확보할 수 있었다.

이 경험을 통해 이벤트 하나의 등록 방식이 전체 렌더링 흐름에 얼마나 큰 영향을 미칠 수 있는지를 뼈저리게 느꼈다. 단순한 비교 조건 하나가 상태 변경 → 이벤트 재등록 → 상태 변경의 무한 사이클을 만들 수 있다는 점은, 추상화된 프레임워크 없이 직접 구현해보지 않았다면 절대 와닿지 않았을 것이다. 작은 로직이라도 실제 렌더링 흐름과 상태 전파에 어떤 영향을 줄 수 있는지 항상 고민해야 한다는 교훈을 얻었다.

### 📦 TypeScript로의 마이그레이션

`Virtual DOM`을 처음부터 직접 구현하면서, 코드의 흐름과 데이터 구조를 더 깊이 이해하고 싶다는 생각이 들었다. 겉으로 보이는 동작만 따라가는 것이 아니라, 각 함수가 어떤 값을 주고받고 어떤 형태로 흘러가는지를 명확히 파악하기 위해 `TypeScript`로 전환을 결심했다. 단순히 타입 안정성을 위한 것이 아니라, 구조를 명확히 인식하고 설계해보기 위한 과정이었다.

가장 먼저 마주친 벽은 `JSX` 처리였다. `React` 환경이 아닌 상태에서 `createVNode`를 `JSX 팩토리 함수`로 쓰기 위해 `tsconfig.json`에 `jsxFactory`, `jsxFragmentFactory`를 명시해줘야 했고, `JSX` 관련 타입을 수동으로 선언한 `jsx.d.ts` 파일도 필요했다. `JSX.IntrinsicElements`, `JSX.Element`, `ElementAttributesProperty` 등을 직접 정의해주면서 `JSX`가 내부적으로 어떤 타입 체계를 가지고 작동하는지 이해하게 되었다.

```ts
declare global {
  namespace JSX {
    interface IntrinsicElements {
      [elemName: string]: Props;
    }

    interface Element extends VNode {}
    interface ElementClass {}
    interface ElementAttributesProperty {
      props: {};
    }
  }
}
```

그리고 실제 `VNode`, `Component`, `Props` 타입들을 설계하며, `flattenChildren`이나 `normalizeVNode`에서 어떤 값이 들어올 수 있는지를 하나하나 따져가며 정리했다. 이 과정에서 자식 노드(children)가 단순히 `VNode[]`일 거라는 가정이 얼마나 위험했는지도 체감했고, `string`, `number`, `null`, `undefined` 같은 다양한 타입이 섞여 들어올 수 있다는 걸 고려해야 했다.

또한 `HTML` 속성과 `JS` 속성명 사이의 차이(`class` vs `className` 등)도 타입으로 명시하려고 하다 보니 더 명확한 분리 기준이 필요해졌고, 이벤트 핸들러의 타입 정의 또한 `(event: Event) => void`로 통일해야 하는 구조도 만들어졌다.

무엇보다 이 작업은 단순히 정적 타입을 붙이는 게 아니라, 내 코드가 어떤 구조로 흘러가고 있는지를 다시 읽는 과정이었다. 타입 선언을 하면서 자연스럽게 관심사가 정리되고, 함수의 입력과 출력이 선명해졌으며, 구조적 문제를 미리 파악할 수 있게 되었다. 이전엔 "이건 대충 객체겠지" 하고 넘어갔던 부분들을, 이제는 "이건 어떤 속성을 가진 어떤 타입이어야 하지?"라고 스스로 질문하게 되었다.

결국 `TypeScript`는 문법이 아니라 사고 방식의 도구라는 걸 다시금 느끼게 된 시간이었다.

### 🧱 구조적 고민과 관심사 분리

`TypeScript`로 마이그레이션을 진행하면서 자연스럽게 프로젝트의 구조를 다시 바라보게 되었다. 그전까지는 모든 기능을 `lib` 폴더 안에 단순히 나열하는 식으로 관리해왔지만, 타입을 붙이기 시작하자 각 함수가 무엇을 책임지고 있는지, 어떤 데이터와 흐름을 다루는지 더 선명하게 보이기 시작했다. 그리고 그 순간부터 구조에 대한 고민이 본격적으로 시작됐다.

어떤 모듈을 클래스로 구성해야 할지에 대한 고민도 함께 따랐다. 예를 들어, `VNode`를 생성하거나 정규화하는 작업은 순수하게 입력을 받아 결과를 반환하는 형태였기 때문에 함수로 처리하는 것이 더 자연스러웠다. 반면, `EventManager`처럼 내부에 상태를 저장해야 하고, 전역적으로 이벤트 위임을 관리해야 하는 기능은 여러 컴포넌트에서 공유되는 단일 인스턴스로 존재할 필요가 있었기 때문에, 클래스 형태로 구현하는 편이 명확하고 적절했다.

이런 고민은 디렉토리 구조에도 그대로 반영됐다. `createObserver`처럼 라우터와 스토어에서 공유되는 기능은 `observer`라는 별도 폴더로 분리했고, `createElement`, `updateElement`, `normalizeVNode`처럼 `Virtual DOM` 구성과 관련된 함수들은 `vdom` 안으로 정리했다. 하지만 그 과정에서 "이 로직은 어디에 두는 게 맞을까?", "이건 상태를 관리하는 쪽일까, 렌더링 쪽일까?" 같은 질문들이 끝없이 따라붙었다.

무엇보다도 어려웠던 건 함수 하나하나의 책임 범위를 어디까지 허용할 것인가였다. `updateElement`나 `updateAttributes`처럼 두 영역을 동시에 다루는 함수들은 자칫하면 역할이 모호해질 수 있었기 때문에, "이 함수는 어디까지 알고 있어도 괜찮은가?"라는 질문을 계속 던지며 분리 기준을 고민했다.

이번 구조 정리를 통해 느낀 것은, 관심사를 분리한다는 건 단순한 파일 분할이 아니라 책임과 역할을 설계하는 일이라는 점이다. 그리고 이건 결국 객체지향, 함수형이라는 기법을 떠나서, 시스템이 어떻게 유기적으로 움직여야 하는지를 파악하려는 시도 그 자체였다.

이번 구조 정리를 통해 느낀 건, 관심사를 분리한다는 건 단순히 파일을 나누는 문제가 아니라 각 기능이 맡아야 할 책임을 명확히 정의하는 일이라는 점이다. 기능 간의 의존성과 흐름을 고민하면서, 어떤 로직이 어디에 있어야 자연스러운지를 계속 고민하게 되었다.

## 과제 중 질문 사항

### 1. 모든 VNode를 메모리에 보관하는 방식은 확장 가능한가?

렌더링마다 새로운 `VNode` 트리를 생성하고 이전 트리와 비교하는 구조는 단순하지만, 결국 전체 `VNode` 구조를 메모리에 들고 있게 된다. 이 방식은 컴포넌트 수가 많아지고 UI가 복잡해질수록 메모리 사용량이 늘어나며, `diffing` 시에도 전체 구조를 재귀적으로 비교하는 부담이 생긴다.
과연 이 구조가 실제 대규모 애플리케이션에서도 충분히 확장 가능할지에 대한 의문이 들었다.

### 2. 자식 노드의 순서 변경이나 삽입을 효율적으로 처리하려면?

현재 구현은 자식 노드를 순서대로 단순 비교해, 중간에 새로운 노드가 추가되거나 순서만 바뀌어도 전체가 교체되는 결과가 발생한다. 이런 방식은 구현이 단순하다는 장점은 있지만, 실제 변화보다 과도한 DOM 변경을 유발할 수 있다.
보다 효율적인 비교 전략은 어떤 방식으로 구현할 수 있을지 고민이 되었다.

### 3. key가 없는 구조에서 리스트의 안정성을 어떻게 확보할 수 있을까?

`React`에서 `key`는 리스트 항목의 일관성을 유지하는 데 핵심적인 역할을 한다. 하지만 현재 구조에서는 `props`에 명시적으로 `key`가 없다면 이를 식별할 방법이 없다. 서버에서 전달되는 데이터에도 `key`가 없다면, 어떤 설계적 접근을 통해 리스트 항목을 안정적으로 구분하고 재사용성을 높일 수 있을까?
`key`가 없는 환경에서도 안정적인 렌더링 흐름을 만드는 방법에 대해 궁금증이 생겼다.

### 4. 렌더링마다 setupEventListeners를 실행하는 구조는 효율적인가?

현재 구조에서는 컴포넌트가 렌더링될 때마다 `setupEventListeners`가 호출되고, 이 함수 내부에서 루트 엘리먼트에 이벤트 위임 처리가 수행된다. 비록 내부적으로는 `WeakMap`과 `Set`을 통해 중복 등록을 방지하고 있지만, 렌더링과 함께 반복적으로 실행된다는 점에서 비용이 우려되었다.
이벤트 위임은 성능 최적화를 위한 기법인데, 이 구조가 과연 실제로도 효율적인 설계일지 의문이 들었다.
